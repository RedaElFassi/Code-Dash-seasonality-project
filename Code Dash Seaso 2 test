import dash
from dash import Dash, dcc, html, Input, Output, State, callback
import plotly.graph_objs as go
import pandas as pd
import numpy as np
from datetime import date, datetime
from typing import Dict, List, Tuple, Optional

"""
Dash app: Yield Seasonality Dashboard (single DataFrame input)
--------------------------------------------------------------
Assumes a **single DataFrame** named `data` is available/importable with columns like:
    "France 2Y", "Germany 10Y", ...
(i.e., f"{Country} {Tenor}", where tenor strings are "1Y","2Y","3Y",...).
Index must be a DatetimeIndex of daily dates; values are numeric yields.

Logic implemented per spec:
- 1 country: 1 mat -> outright; 2 -> long-short; 3 -> 2*mid - long - short
- 2 countries: base = higher LONG maturity each date; then
    1 mat  -> higher-lower (that mat)
    2 mats -> (LongDiff - ShortDiff)
    3 mats -> 2*MidDiff - LongDiff - ShortDiff
- 3 countries: exactly 1 mat -> cross-country fly = 2*median - high - low

Seasonality plot #1:
- Current month (e.g., August of today)
- N last completed years (1..10), default 10
- For each year, curve from first available trading day ON/AFTER day 1 of month to first
  available trading day ON/AFTER day 1 of next month. X-axis is day offset from that first day.

Run locally:
    pip install dash plotly pandas numpy
    python seasonality_dash_app.py
Then open http://127.0.0.1:8050 (or the printed LAN URL)
"""

# -----------------------------
# Configurable universes
# -----------------------------
DEFAULT_COUNTRIES = [
    "Germany", "France", "Italy", "Spain", "Portugal", "Greece", "Finland", "Belgium"
]
DEFAULT_MATURITIES = [2, 5, 7, 10, 15, 20, 25, 30]

# -----------------------------
# Try to locate `data` (single DataFrame) in global scope or import from data_loader
# -----------------------------
try:
    data  # type: ignore[name-defined]
except Exception:
    try:
        from data_loader import data  # type: ignore
    except Exception:
        data = None  # will render a warning in the UI

# -----------------------------
# Utility helpers
# -----------------------------

def m_bucket(m: int) -> str:
    return f"{int(m)}Y"


def ensure_datetime_index(df: pd.DataFrame) -> pd.DataFrame:
    if not isinstance(df.index, pd.DatetimeIndex):
        df = df.copy()
        df.index = pd.to_datetime(df.index)
    return df.sort_index()


def get_series(country: str, maturity: int, data_df: pd.DataFrame) -> pd.Series:
    col = f"{country} {m_bucket(maturity)}"
    df = ensure_datetime_index(data_df)
    if col not in df.columns:
        raise KeyError(f"Column '{col}' not found in `data`.")
    return df[col].astype(float).dropna().rename(col)


def align_on_index(series_list: List[pd.Series]) -> pd.DataFrame:
    df = pd.concat(series_list, axis=1, join="inner").dropna(how="any")
    df.index = pd.to_datetime(df.index)
    return df.sort_index()


def compute_combination(countries: List[str], maturities: List[int], data_df: pd.DataFrame) -> Tuple[pd.Series, str]:
    nC = len(countries)
    nM = len(maturities)
    if nC == 0 or nM == 0:
        raise ValueError("Select at least one country and one maturity.")
    maturities = sorted(maturities)
    m_names = [m_bucket(m) for m in maturities]

    if nC == 1:
        c = countries[0]
        if nM == 1:
            s = get_series(c, maturities[0], data_df)
            return s, f"{c} {m_names[0]} (outright)"
        if nM == 2:
            s_long = get_series(c, maturities[1], data_df)
            s_short = get_series(c, maturities[0], data_df)
            df = align_on_index([s_long, s_short])
            out = (df.iloc[:, 0] - df.iloc[:, 1]).rename(f"{c} {m_names[1]} - {m_names[0]}")
            return out, out.name
        if nM == 3:
            s_short = get_series(c, maturities[0], data_df)
            s_mid   = get_series(c, maturities[1], data_df)
            s_long  = get_series(c, maturities[2], data_df)
            df = align_on_index([s_short, s_mid, s_long])
            out = (2*df.iloc[:,1] - df.iloc[:,2] - df.iloc[:,0]).rename(
                f"2*{c} {m_names[1]} - {c} {m_names[2]} - {c} {m_names[0]}"
            )
            return out, out.name
        raise ValueError("With 1 country, select 1 to 3 maturities.")

    if nC == 2:
        c1, c2 = countries
        if nM == 1:
            s1 = get_series(c1, maturities[0], data_df)
            s2 = get_series(c2, maturities[0], data_df)
            df = align_on_index([s1, s2])
            higher = df.max(axis=1)
            lower  = df.min(axis=1)
            out = (higher - lower).rename(f"max({c1},{c2}) {m_names[0]} - min({c1},{c2}) {m_names[0]}")
            return out, out.name
        if nM == 2:
            mS, mL = maturities[0], maturities[1]
            s1L, s2L = get_series(c1, mL, data_df), get_series(c2, mL, data_df)
            s1S, s2S = get_series(c1, mS, data_df), get_series(c2, mS, data_df)
            df = align_on_index([s1L, s2L, s1S, s2S])
            base_is_c1 = df.iloc[:,0] >= df.iloc[:,1]
            long_diff  = np.where(base_is_c1, df.iloc[:,0]-df.iloc[:,1], df.iloc[:,1]-df.iloc[:,0])
            short_diff = np.where(base_is_c1, df.iloc[:,2]-df.iloc[:,3], df.iloc[:,3]-df.iloc[:,2])
            out = pd.Series(long_diff - short_diff, index=df.index).rename(
                f"({m_bucket(mL)} diff) - ({m_bucket(mS)} diff) base=argmax long({c1},{c2})"
            )
            return out, out.name
        if nM == 3:
            mS, mM, mL = maturities[0], maturities[1], maturities[2]
            s1L, s2L = get_series(c1, mL, data_df), get_series(c2, mL, data_df)
            s1M, s2M = get_series(c1, mM, data_df), get_series(c2, mM, data_df)
            s1S, s2S = get_series(c1, mS, data_df), get_series(c2, mS, data_df)
            df = align_on_index([s1L, s2L, s1M, s2M, s1S, s2S])
            base_is_c1 = df.iloc[:,0] >= df.iloc[:,1]
            long_diff  = np.where(base_is_c1, df.iloc[:,0]-df.iloc[:,1], df.iloc[:,1]-df.iloc[:,0])
            mid_diff   = np.where(base_is_c1, df.iloc[:,2]-df.iloc[:,3], df.iloc[:,3]-df.iloc[:,2])
            short_diff = np.where(base_is_c1, df.iloc[:,4]-df.iloc[:,5], df.iloc[:,5]-df.iloc[:,4])
            out = pd.Series(2*mid_diff - long_diff - short_diff, index=df.index).rename(
                f"2*({m_bucket(mM)} diff) - ({m_bucket(mL)} diff) - ({m_bucket(mS)} diff) base=argmax long({c1},{c2})"
            )
            return out, out.name
        raise ValueError("With 2 countries, select 1 to 3 maturities.")

    if nC == 3:
        if nM != 1:
            raise ValueError("With 3 countries, select exactly 1 maturity.")
        cA, cB, cC = countries
        m = maturities[0]
        sA, sB, sC = get_series(cA, m, data_df), get_series(cB, m, data_df), get_series(cC, m, data_df)
        df = align_on_index([sA, sB, sC])
        arr = df.values
        high = arr.max(axis=1)
        low  = arr.min(axis=1)
        med  = arr.sum(axis=1) - high - low
        out = pd.Series(2*med - high - low, index=df.index).rename(
            f"2*Median({cA},{cB},{cC}) {m_bucket(m)} - High - Low"
        )
        return out, out.name

    raise ValueError("Select between 1 and 3 countries.")


# -----------------------------
# Seasonality helpers
# -----------------------------

def month_window_for_year(year: int, month: int) -> Tuple[pd.Timestamp, pd.Timestamp]:
    start = pd.Timestamp(year=year, month=month, day=1)
    end = pd.Timestamp(year=year+1, month=1, day=1) if month == 12 else pd.Timestamp(year=year, month=month+1, day=1)
    return start, end


def first_on_or_after(idx: pd.DatetimeIndex, dt: pd.Timestamp) -> Optional[pd.Timestamp]:
    pos = idx.searchsorted(dt)
    if pos < len(idx):
        return idx[pos]
    return None


def last_before(idx: pd.DatetimeIndex, dt: pd.Timestamp) -> Optional[pd.Timestamp]:
    pos = idx.searchsorted(dt)
    if pos == 0:
        return None
    return idx[pos-1]


def slice_month_segment(s: pd.Series, year: int, month: int) -> pd.Series:
    idx = s.index
    start_month, end_month = month_window_for_year(year, month)
    a = first_on_or_after(idx, start_month)
    b = last_before(idx, end_month)
    if a is None or b is None or a > b:
        return pd.Series(dtype=float)
    seg = s.loc[a:b].copy()
    # Normalize so each year's segment starts at 0 (subtract first trading day's value)
    start_val = float(seg.iloc[0])
    seg = seg - start_val
    # X-axis index as offsets from CALENDAR 1st-of-month, so ticks can be 01/MM, 06/MM, ...
    return pd.Series(seg.values, index=(seg.index - start_month).days)


def build_intramonth_profiles(s: pd.Series, month: int, years_back: int) -> Dict[int, pd.Series]:
    if s.empty:
        return {}
    current_year = date.today().year
    years = list(range(current_year - 1, current_year - years_back - 1, -1))
    profiles: Dict[int, pd.Series] = {}
    for y in sorted(years):
        seg = slice_month_segment(s, y, month)
        if not seg.empty:
            profiles[y] = seg
    return profiles


# -----------------------------
# Build Dash layout
# -----------------------------
app: Dash = dash.Dash(__name__)
app.title = "Seasonality Project"

app.layout = html.Div([
    html.H2("ðŸ“ˆ Yield Seasonality Dashboard (Dash)"),
    html.Hr(),

    # Warning if no data found
    html.Div(id="data-warning", style={"color": "crimson", "marginBottom": "10px"}),

    html.Div([
        html.Div([
            html.Label("Countries (1â€“3)"),
            dcc.Checklist(
                id="countries",
                options=[{"label": c, "value": c} for c in DEFAULT_COUNTRIES],
                value=["France"],
                inline=False,
                inputStyle={"marginRight": "6px"},
                labelStyle={"display": "block"},
            ),
        ], style={"width": "30%", "display": "inline-block", "verticalAlign": "top"}),

        html.Div([
            html.Label("Maturities (1â€“3)"),
            dcc.Checklist(
                id="maturities",
                options=[{"label": str(m), "value": m} for m in DEFAULT_MATURITIES],
                value=[10],
                inline=False,
                inputStyle={"marginRight": "6px"},
                labelStyle={"display": "inline-block"},
            ),
        ], style={"width": "30%", "display": "inline-block", "marginLeft": "2%", "verticalAlign": "top"}),

        html.Div([
            html.Label("Last N completed years"),
            dcc.Slider(id="years-back", min=1, max=10, step=1, value=10,
                       marks={i: str(i) for i in range(1, 11)}),
            html.Div(id="current-month", style={"marginTop": "10px"}),
        ], style={"width": "35%", "display": "inline-block", "marginLeft": "2%", "verticalAlign": "top"}),
    ]),

    html.Hr(),
    html.H4("Constructed series"),
    html.Div(id="series-label", style={"fontStyle": "italic", "marginBottom": "10px"}),

    dcc.Graph(id="seasonality-graph", config={"displaylogo": False}),

    
])


# -----------------------------
# Callbacks
# -----------------------------
@callback(
    Output("data-warning", "children"),
    Output("current-month", "children"),
    Output("series-label", "children"),
    Output("seasonality-graph", "figure"),
    Input("countries", "value"),
    Input("maturities", "value"),
    Input("years-back", "value"),
)
def update_graph(countries_sel, maturities_sel, years_back):
    # Data availability warning
    if data is None:
        warn = "No `data` DataFrame found. Provide it via `data_loader.py` or in the global scope."
        return warn, "", "", go.Figure()

    # Validate selections
    countries_sel = countries_sel or []
    maturities_sel = maturities_sel or []
    if len(countries_sel) == 0 or len(maturities_sel) == 0:
        return "", "", "Select at least one country and one maturity.", go.Figure()
    if len(countries_sel) > 3:
        return "", "", "Please select at most 3 countries.", go.Figure()
    if len(maturities_sel) > 3:
        return "", "", "Please select at most 3 maturities.", go.Figure()
    if len(countries_sel) == 3 and len(maturities_sel) != 1:
        return "", "", "With 3 countries, select exactly 1 maturity.", go.Figure()

    # Compute series
    try:
        series, label = compute_combination(list(countries_sel), list(map(int, maturities_sel)), data)
    # Convert to basis points (input is in %)
    series = series * 100.0, list(map(int, maturities_sel)), data)
    except Exception as e:
        return "", "", f"Error computing series: {e}", go.Figure()

    # Build seasonality profiles
    month_idx = date.today().month
    month_name = datetime(date.today().year, month_idx, 1).strftime("%B")
    profiles = build_intramonth_profiles(series.dropna(), month=month_idx, years_back=int(years_back))

    if not profiles:
        fig = go.Figure()
        fig.update_layout(title=f"No data for {month_name} across selected years")
        return "", f"Current month: {month_name}", label, fig

    # Build figure
    fig = go.Figure()
    max_x = 0
    for y in sorted(profiles.keys()):
        seg = profiles[y]
        fig.add_trace(go.Scatter(x=seg.index.values, y=seg.values, mode="lines", name=str(y)))
        if len(seg.index) and int(np.nanmax(seg.index.values)) > max_x:
            max_x = int(np.nanmax(seg.index.values))

    # Build tick labels every 5 days from the calendar start of the month
    import pandas as pd as _pd  # not used; avoid name clash (noop)
    start_calendar = pd.Timestamp(year=date.today().year, month=month_idx, day=1)
    tickvals = list(range(0, max_x + 1, 5))
    ticktext = [ (start_calendar + pd.Timedelta(days=int(d))).strftime("%d/%m") for d in tickvals ]

    fig.update_layout(
        title=f"Seasonality â€” {label} â€” {month_name}",
        xaxis_title="Days since first trading day of month",
        yaxis_title="Yield combination (bps)",
        legend_title="Year",
        template="plotly_white",
        xaxis=dict(
            tickmode="array",
            tickvals=tickvals,
            ticktext=ticktext,
            tickangle=180
        ),
        margin=dict(l=40, r=20, t=50, b=80),
    ),
    )

    return "", f"Current month: {month_name}", label, fig


if __name__ == "__main__":
    # Run and share on LAN; open local browser automatically
    import webbrowser
    import socket

    def get_local_ip():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    host = "0.0.0.0"
    port = 8050
    local_ip = get_local_ip()

    print("
================= SHARE THIS =================")
    print(f"Local (toi)    : http://localhost:{port}")
    print(f"RÃ©seau (Ã©quipe): http://{local_ip}:{port}")
    print("==============================================
")

    webbrowser.open(f"http://localhost:{port}")
    app.run_server(host=host, port=port, debug=False)
