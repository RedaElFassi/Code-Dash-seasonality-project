import dash
from dash import Dash, dcc, html, Input, Output, State, callback, dash_table
import plotly.graph_objs as go
import pandas as pd
import numpy as np
from datetime import date, datetime, timedelta
from calendar import monthrange
from typing import Dict, List, Tuple, Optional

"""
Yield Seasonality Dashboard â€” 3 selectors (Country1/2/3 on one row) + 3 weights aligned below
- Weights used ONLY when:
  * 2 countries & 2 maturities (BOX): W1=long spread weight; W2 or W3 = short spread weight
      (if counterparty is Country2 -> use W2; if counterparty is Country3 -> use W3)
  * 3 countries & 1 maturity (CREDIT FLY): W2*C2 - W1*C1 - W3*C3
- For 1 country (outright/steep/fly) or 2 countries with 1/3 maturities,
  weights are ignored; we use the canonical formulas.

Heatmap:
- Rows: "Average" first, then current year (if selected) and past years in DESC order (e.g., 2025, 2024, â€¦).
- Values = end-of-month minus start-of-month (bps), 1 decimal text printed in black.
- Months displayed at TOP (columns), diverging redâ†’green palette, zmid=0.

Beta-hedged seasonality:
- Visible ONLY if exactly 2 countries & 2 maturities (a BOX).
- Canonical definitions used for regression:
    box = (C1 L - Cx L) - (C1 S - Cx S)        [no custom weights here]
    long = (C1 L - Cx L)
- Per-year beta via OLS slope (with intercept) on the chosen lookback window that ENDS on the anchor date
  (start of the plotting window). If a Beta override is provided AND applied, we use it for all years/graphs.
- Displayed series = (box - beta*long), then CENTERED to zero at the first point of the plotting window.

Assumes a single DataFrame `data` with columns "France 2Y", "Germany 10Y", â€¦ (yields in % or bps).
"""

# -----------------------------
# Universe
# -----------------------------
DEFAULT_COUNTRIES = [
    "Germany", "France", "Italy", "Spain", "Portugal", "Greece", "Finland", "Belgium"
]
DEFAULT_MATURITIES = [2, 5, 7, 10, 15, 20, 25, 30]
MONTH_NAMES = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]

# -----------------------------
# Resolve `data`
# -----------------------------
try:
    data  # type: ignore[name-defined]
except Exception:
    try:
        from data_loader import data  # type: ignore
    except Exception:
        data = None

# -----------------------------
# Helpers
# -----------------------------
def m_bucket(m: int) -> str:
    return f"{int(m)}Y"

def ensure_datetime_index(df: pd.DataFrame) -> pd.DataFrame:
    if not isinstance(df.index, pd.DatetimeIndex):
        df = df.copy()
        df.index = pd.to_datetime(df.index)
    return df.sort_index()

def get_series(country: str, maturity: int, data_df: pd.DataFrame) -> pd.Series:
    col = f"{country} {m_bucket(maturity)}"
    df = ensure_datetime_index(data_df)
    if col not in df.columns:
        raise KeyError(f"Column '{col}' not found in `data`.")
    return df[col].astype(float).dropna().rename(col)

def align_on_index(series_list: List[pd.Series]) -> pd.DataFrame:
    df = pd.concat(series_list, axis=1, join="inner").dropna(how="any")
    df.index = pd.to_datetime(df.index)
    return df.sort_index()

def first_on_or_after(idx: pd.DatetimeIndex, dt: pd.Timestamp) -> Optional[pd.Timestamp]:
    pos = idx.searchsorted(dt)
    if pos < len(idx):
        return idx[pos]
    return None

def last_before(idx: pd.DatetimeIndex, dt: pd.Timestamp) -> Optional[pd.Timestamp]:
    pos = idx.searchsorted(dt)
    if pos == 0:
        return None
    return idx[pos-1]

def month_window_for_year(year: int, month: int) -> Tuple[pd.Timestamp, pd.Timestamp]:
    start = pd.Timestamp(year=year, month=month, day=1)
    end = pd.Timestamp(year=year+1, month=1, day=1) if month == 12 else pd.Timestamp(year=year, month=month+1, day=1)
    return start, end

def slice_window_segment(s: pd.Series, start_cal: datetime, end_cal: datetime, center_to_zero: bool = True) -> pd.Series:
    """Return segment as values vs CALENDAR-offset days since start_cal. Optionally center to zero."""
    idx = s.index
    a = first_on_or_after(idx, pd.Timestamp(start_cal))
    b = last_before(idx, pd.Timestamp(end_cal))
    if a is None or b is None or a > b:
        return pd.Series(dtype=float)
    seg = s.loc[a:b].copy()
    if center_to_zero and len(seg):
        seg = seg - float(seg.iloc[0])
    # Index is in calendar day offsets from START CALENDAR (not trading day count)
    return pd.Series(seg.values, index=(seg.index - pd.Timestamp(start_cal)).days)

def slice_window_segment_levels(s: pd.Series, start_cal: datetime, end_cal: datetime) -> pd.Series:
    """Segment in absolute levels, indexed by actual timestamps (not offsets)."""
    idx = s.index
    a = first_on_or_after(idx, pd.Timestamp(start_cal))
    b = last_before(idx, pd.Timestamp(end_cal))
    if a is None or b is None or a > b:
        return pd.Series(dtype=float)
    return s.loc[a:b].copy()

def slice_month_segment(s: pd.Series, year: int, month: int) -> pd.Series:
    start_month, end_month = month_window_for_year(year, month)
    return slice_window_segment(s, start_month.to_pydatetime(), end_month.to_pydatetime(), center_to_zero=True)

def build_intramonth_profiles(s: pd.Series, month: int, years_back: int) -> Dict[int, pd.Series]:
    """Current calendar month â€” return a dict {year: centered segment} for the N past years (1..N)."""
    if s.empty:
        return {}
    current_year = date.today().year
    years = list(range(current_year - 1, current_year - years_back - 1, -1))
    profiles: Dict[int, pd.Series] = {}
    for y in sorted(years):
        seg = slice_month_segment(s, y, month)
        if not seg.empty:
            profiles[y] = seg
    return profiles

def safe_ymd(y: int, m: int, d: int) -> datetime:
    last_d = monthrange(y, m)[1]
    return datetime(y, m, min(d, last_d))

def build_profiles_anchor_day_next_month(s: pd.Series, years_back: int) -> Tuple[Dict[int, pd.Series], str]:
    """Window: [today's day-of-month â†’ same day next month], for each past year."""
    today_dt = date.today()
    day, month, year = today_dt.day, today_dt.month, today_dt.year

    title_start = datetime(year, month, min(day, monthrange(year, month)[1])).strftime("%d-%b")
    if month == 12:
        title_end = datetime(year + 1, 1, min(day, monthrange(year + 1, 1)[1])).strftime("%d-%b")
    else:
        title_end = datetime(year, month + 1, min(day, monthrange(year, month + 1)[1])).strftime("%d-%b")

    profiles: Dict[int, pd.Series] = {}
    for y in range(year - years_back, year):
        start_cal = safe_ymd(y, month, day)
        end_cal = safe_ymd(y + (1 if month == 12 else 0), 1 if month == 12 else month + 1, day)
        seg = slice_window_segment(s, start_cal, end_cal, center_to_zero=True)
        if not seg.empty:
            profiles[y] = seg
    return profiles, f"{title_start} to {title_end}"

def build_profiles_next_month(s: pd.Series, years_back: int) -> Tuple[Dict[int, pd.Series], str]:
    """Window: [1st of NEXT month â†’ 1st of the following month], for each past year."""
    today = date.today()
    month = today.month
    year = today.year

    if month == 12:
        start_title = datetime(year + 1, 1, 1)
        end_title = datetime(year + 1, 2, 1)
    elif month == 11:
        start_title = datetime(year, 12, 1)
        end_title = datetime(year + 1, 1, 1)
    else:
        start_title = datetime(year, month + 1, 1)
        end_title = datetime(year, month + 2, 1)

    profiles: Dict[int, pd.Series] = {}
    for y in range(year - years_back, year):
        if month == 12:
            start_cal = datetime(y + 1, 1, 1)
            end_cal = datetime(y + 1, 2, 1)
        elif month == 11:
            start_cal = datetime(y, 12, 1)
            end_cal = datetime(y + 1, 1, 1)
        else:
            start_cal = datetime(y, month + 1, 1)
            end_cal = datetime(y, month + 2, 1)
        seg = slice_window_segment(s, start_cal, end_cal, center_to_zero=True)
        if not seg.empty:
            profiles[y] = seg

    return profiles, f"{start_title.strftime('%d-%b')} to {end_title.strftime('%d-%b')}"

def build_average_profile(profiles: Dict[int, pd.Series]) -> Optional[pd.Series]:
    """Average by calendar-offset index; keep 0 at 0."""
    if not profiles:
        return None
    df = pd.concat(list(profiles.values()), axis=1)
    df.columns = list(profiles.keys())
    avg = df.mean(axis=1, skipna=True)
    if 0 in avg.index:
        avg.loc[0] = 0.0
    return avg.sort_index()

# -----------------------------
# Weighted combination logic (3 dropdowns + 3 weights)
# -----------------------------
def compute_weighted_series(
    c1: Optional[str], c2: Optional[str], c3: Optional[str],
    maturities: List[int],
    w1: float, w2: float, w3: float,
    data_df: pd.DataFrame
) -> Tuple[pd.Series, str]:
    """
    - 1 country:
        1 mat -> outright
        2 mats -> long - short
        3 mats -> 2*mid - long - short
    - 2 countries: base = Country 1 (C1), other = the one filled among C2/C3.
        1 mat -> C1 - Cx
        2 mats (BOX) -> W1*(C1 L - Cx L) - Wk*(C1 S - Cx S)
            where k=2 if Cx is Country2, else k=3 if Cx is Country3
        3 mats -> 2*(C1 M - Cx M) - (C1 L - Cx L) - (C1 S - Cx S)   [weights ignored]
    - 3 countries (require 1 mat) -> W2*C2 - W1*C1 - W3*C3
    """
    sel_countries = [c for c in [c1, c2, c3] if c]
    nC = len(sel_countries)
    nM = len(maturities)
    if nC == 0 or nM == 0:
        raise ValueError("Select at least one country and one maturity.")
    maturities = sorted(maturities)
    mS = maturities[0]
    mM = maturities[1] if nM >= 2 else None
    mL = maturities[2] if nM >= 3 else (maturities[1] if nM == 2 else None)

    # 1 country
    if nC == 1:
        c = sel_countries[0]
        if nM == 1:
            s = get_series(c, mS, data_df)
            return s, f"{c} {m_bucket(mS)} (outright)"
        if nM == 2:
            s_short = get_series(c, mS, data_df)
            s_long  = get_series(c, mL, data_df)  # type: ignore[arg-type]
            df = align_on_index([s_long, s_short])
            out = (df.iloc[:,0] - df.iloc[:,1]).rename(f"{c} {m_bucket(mL)} - {m_bucket(mS)}")
            return out, out.name
        if nM == 3:
            s_short = get_series(c, mS, data_df)
            s_mid   = get_series(c, mM, data_df)  # type: ignore[arg-type]
            s_long  = get_series(c, mL, data_df)  # type: ignore[arg-type]
            df = align_on_index([s_mid, s_long, s_short])
            out = (2*df.iloc[:,0] - df.iloc[:,1] - df.iloc[:,2]).rename(
                f"2*{c} {m_bucket(mM)} - {c} {m_bucket(mL)} - {c} {m_bucket(mS)}"  # type: ignore[arg-type]
            )
            return out, out.name
        raise ValueError("With 1 country, select 1â€“3 maturities.")

    # 2 countries
    if nC == 2:
        if not c1:
            raise ValueError("Country 1 must be set to define the base.")
        Cx = c2 if c2 else c3
        assert Cx is not None
        if nM == 1:
            s1 = get_series(c1, mS, data_df)
            s2 = get_series(Cx, mS, data_df)
            df = align_on_index([s1, s2])
            out = (df.iloc[:,0] - df.iloc[:,1]).rename(f"{c1} - {Cx} {m_bucket(mS)}")
            return out, out.name
        if nM == 2:
            # BOX with WEIGHTS: W1 for long; W2/W3 (depending which counterparty) for short
            W_long = float(w1)
            W_short = float(w2 if (Cx == c2) else w3)
            s1L, s2L = get_series(c1, mL, data_df), get_series(Cx, mL, data_df)  # type: ignore[arg-type]
            s1S, s2S = get_series(c1, mS, data_df), get_series(Cx, mS, data_df)
            df = align_on_index([s1L, s2L, s1S, s2S])
            long_spread  = df.iloc[:,0] - df.iloc[:,1]
            short_spread = df.iloc[:,2] - df.iloc[:,3]
            out = (W_long*long_spread - W_short*short_spread).rename(
                f"{W_long}*({c1} {m_bucket(mL)} - {Cx} {m_bucket(mL)}) - {W_short}*({c1} {m_bucket(mS)} - {Cx} {m_bucket(mS)})"
            )
            return out, out.name
        if nM == 3:
            s1L, s2L = get_series(c1, mL, data_df), get_series(Cx, mL, data_df)  # type: ignore[arg-type]
            s1M, s2M = get_series(c1, mM, data_df), get_series(Cx, mM, data_df)  # type: ignore[arg-type]
            s1S, s2S = get_series(c1, mS, data_df), get_series(Cx, mS, data_df)
            df = align_on_index([s1M, s2M, s1L, s2L, s1S, s2S])
            mid_spread   = df.iloc[:,0] - df.iloc[:,1]
            long_spread  = df.iloc[:,2] - df.iloc[:,3]
            short_spread = df.iloc[:,4] - df.iloc[:,5]
            out = (2*mid_spread - long_spread - short_spread).rename(
                f"2*({c1} {m_bucket(mM)} - {Cx} {m_bucket(mM)}) - ({c1} {m_bucket(mL)} - {Cx} {m_bucket(mL)}) - ({c1} {m_bucket(mS)} - {Cx} {m_bucket(mS)})"
            )
            return out, out.name
        raise ValueError("With 2 countries, select 1â€“3 maturities.")

    # 3 countries (require 1 mat)
    if nC == 3:
        if nM != 1:
            raise ValueError("With 3 countries, select exactly 1 maturity.")
        s1 = get_series(c1, mS, data_df) if c1 else None
        s2 = get_series(c2, mS, data_df) if c2 else None
        s3 = get_series(c3, mS, data_df) if c3 else None
        series_list = [x for x in [s1, s2, s3] if x is not None]
        df = align_on_index(series_list)  # type: ignore[arg-type]
        # Map columns to C1,C2,C3 order
        cols_map = {}
        if c1: cols_map['C1'] = df.filter(like=c1).columns[0]
        if c2: cols_map['C2'] = df.filter(like=c2).columns[0]
        if c3: cols_map['C3'] = df.filter(like=c3).columns[0]
        out = ( float(w2)*df[cols_map['C2']] - float(w1)*df[cols_map['C1']] - float(w3)*df[cols_map['C3']] ).rename(
            f"{float(w2)}*{c2} {m_bucket(mS)} - {float(w1)}*{c1} {m_bucket(mS)} - {float(w3)}*{c3} {m_bucket(mS)}"
        )
        return out, out.name

    raise ValueError("Invalid selection state.")

# -----------------------------
# Heatmap monthly deltas (bps)
# -----------------------------
def month_delta(series: pd.Series, year: int, month: int) -> Optional[float]:
    if series.empty:
        return None
    start, end = month_window_for_year(year, month)
    a = first_on_or_after(series.index, start)
    b = last_before(series.index, end)
    if a is None or b is None or a > b:
        return None
    s = float(series.loc[a])
    e = float(series.loc[b])
    return e - s

def build_heatmap_df(series: pd.Series, years: List[int], include_current_year: bool) -> pd.DataFrame:
    """Rows: 'Average' first, then years in DESC (e.g., 2025, 2024, â€¦). Cols: Jan..Dec."""
    years_list = list(sorted(years, reverse=True))
    if include_current_year and (date.today().year not in years_list):
        years_list = [date.today().year] + years_list

    rows = []
    for y in years_list:
        row = []
        for m in range(1, 13):
            d = month_delta(series, y, m)
            row.append(np.nan if d is None else d)
        rows.append(row)

    df = pd.DataFrame(rows, index=[str(y) for y in years_list], columns=MONTH_NAMES)
    avg = df.mean(axis=0, skipna=True)
    df = pd.concat([pd.DataFrame([avg], index=["Average"], columns=MONTH_NAMES), df], axis=0)
    return df

def heatmap_figure(df: pd.DataFrame) -> go.Figure:
    z = df.values.astype(float)
    # Pretty diverging palette (soft reds -> light -> greens), zmid=0 like Bloomberg vibe
    palette = [
        [0.0,  "#7f0000"],  # dark red
        [0.2,  "#d7301f"],
        [0.4,  "#fc8d59"],
        [0.5,  "#f7f7f7"],  # near zero
        [0.6,  "#c7e9c0"],
        [0.8,  "#1a9850"],
        [1.0,  "#00441b"]   # dark green
    ]
    text_vals = np.where(np.isfinite(z), np.round(z, 1), np.nan)
    fig = go.Figure(data=go.Heatmap(
        z=z,
        x=list(df.columns),
        y=list(df.index),
        colorscale=palette,
        zmid=0,
        colorbar=dict(title="Î” (bps)"),
        text=text_vals,
        texttemplate="%{text}",
        textfont={"color":"black","size":12},
        hovertemplate="<b>%{y}</b> â€” %{x}<br>Î”: %{z:.1f} bps<extra></extra>",
    ))
    fig.update_layout(
        template="plotly_white",
        xaxis=dict(side="top", tickangle=0),
        yaxis=dict(autorange="reversed"),  # "Average" stays at top
        margin=dict(l=60, r=20, t=40, b=40),
    )
    return fig

# -----------------------------
# Regression / beta-hedged helpers (ONLY for canonical BOX: 2 countries & 2 maturities)
# -----------------------------
def regression_beta(y: pd.Series, x: pd.Series) -> Optional[float]:
    """OLS slope with intercept, aligning dates. y ~ a + beta*x -> return beta."""
    df = align_on_index([y, x])
    if len(df) < 10:
        return None
    # polyfit returns slope, intercept for x->y (degree=1)
    slope, intercept = np.polyfit(df.iloc[:,1].values, df.iloc[:,0].values, 1)
    return float(slope)

def build_canonical_box_and_long(
    c1: str, cx: str, m_short: int, m_long: int, data_df: pd.DataFrame
) -> Tuple[pd.Series, pd.Series]:
    """Canonical BOX & LONG in bps (levels)."""
    s1L, s2L = get_series(c1, m_long, data_df), get_series(cx, m_long, data_df)
    s1S, s2S = get_series(c1, m_short, data_df), get_series(cx, m_short, data_df)
    df = align_on_index([s1L, s2L, s1S, s2S])
    long = (df.iloc[:,0] - df.iloc[:,1]) * 100.0
    box  = long - (df.iloc[:,2] - df.iloc[:,3])*100.0
    return box.rename("box_bps"), long.rename("long_bps")

def window_start_graph1(y: int) -> datetime:
    m = date.today().month
    return datetime(y, m, 1)

def window_start_graph2(y: int) -> datetime:
    t = date.today()
    return safe_ymd(y, t.month, t.day)

def window_start_graph3(y: int) -> datetime:
    t = date.today()
    if t.month == 12:
        return datetime(y + 1, 1, 1)
    else:
        return datetime(y, t.month + 1, 1)

def window_end_one_month_after(start_dt: datetime) -> datetime:
    y, m = start_dt.year, start_dt.month
    if m == 12:
        return datetime(y + 1, 1, 1)
    else:
        return datetime(y, m + 1, 1)

def lookback_delta(choice: str) -> timedelta:
    if choice == "3M":
        return timedelta(days=90)
    if choice == "6M":
        return timedelta(days=182)
    return timedelta(days=365)

# -----------------------------
# App layout
# -----------------------------
app: Dash = dash.Dash(__name__)
app.title = "Seasonality Project"

app.layout = html.Div([
    html.H2("ðŸ“ˆ Yield Seasonality Dashboard (Dash)"),
    html.Hr(),

    # Data warning
    html.Div(id="data-warning", style={"color": "crimson", "marginBottom": "10px"}),

    # Countries (one row) + Weights (row below aligned under each country)
    html.Div([
        html.Div([
            html.Label("Country 1 (base)"),
            dcc.Dropdown(id="country1", options=[{"label": c, "value": c} for c in DEFAULT_COUNTRIES],
                         value="France", clearable=True),
        ], style={"display":"inline-block","width":"32%","paddingRight":"1%"}),
        html.Div([
            html.Label("Country 2"),
            dcc.Dropdown(id="country2", options=[{"label": c, "value": c} for c in DEFAULT_COUNTRIES],
                         value="Germany", clearable=True),
        ], style={"display":"inline-block","width":"32%","paddingRight":"1%"}),
        html.Div([
            html.Label("Country 3"),
            dcc.Dropdown(id="country3", options=[{"label": c, "value": c} for c in DEFAULT_COUNTRIES],
                         value=None, clearable=True),
        ], style={"display":"inline-block","width":"32%"}),
    ], style={"marginBottom":"6px"}),

    html.Div([
        html.Div([
            html.Label("Weight 1"),
            dcc.Input(id="w1", type="number", value=1.0, step=0.1, min=0),
            html.Div("â€¢ BOX: long spread weight", style={"fontSize":"12px","color":"#555"}),
            html.Div("â€¢ 3 countries: weight for Country 1 (negative sign applied in formula)", style={"fontSize":"12px","color":"#555"})
        ], style={"display":"inline-block","width":"32%","paddingRight":"1%","verticalAlign":"top"}),

        html.Div([
            html.Label("Weight 2"),
            dcc.Input(id="w2", type="number", value=1.0, step=0.1, min=0),
            html.Div("â€¢ BOX: short spread weight if using Country 2 as counterparty", style={"fontSize":"12px","color":"#555"}),
            html.Div("â€¢ 3 countries: weight for Country 2 (positive in formula)", style={"fontSize":"12px","color":"#555"})
        ], style={"display":"inline-block","width":"32%","paddingRight":"1%","verticalAlign":"top"}),

        html.Div([
            html.Label("Weight 3"),
            dcc.Input(id="w3", type="number", value=1.0, step=0.1, min=0),
            html.Div("â€¢ BOX: short spread weight if using Country 3 as counterparty", style={"fontSize":"12px","color":"#555"}),
            html.Div("â€¢ 3 countries: weight for Country 3 (negative sign applied in formula)", style={"fontSize":"12px","color":"#555"})
        ], style={"display":"inline-block","width":"32%","verticalAlign":"top"}),
    ], style={"marginBottom":"12px"}),

    # Maturities + Years
    html.Div([
        html.Div([
            html.Label("Maturities (1â€“3)"),
            dcc.Checklist(
                id="maturities",
                options=[{"label": str(m), "value": m} for m in DEFAULT_MATURITIES],
                value=[10],
                inline=True,
                inputStyle={"marginRight": "6px"},
                labelStyle={"marginRight":"12px"},
            ),
        ], style={"display":"inline-block","width":"60%"}),
        html.Div([
            html.Label("Lookback years (N)"),
            dcc.Slider(id="years-back", min=1, max=10, step=1, value=10,
                       marks={i: str(i) for i in range(1, 11)}),
            html.Div(id="current-month", style={"marginTop":"6px","color":"#555"}),
        ], style={"display":"inline-block","width":"39%","verticalAlign":"top","paddingLeft":"1%"}),
    ]),

    html.Div(id="hide-years-container", style={"marginTop":"6px"}),

    html.Hr(),
    html.H4("Constructed series"),
    html.Div(id="series-label", style={"fontStyle": "italic", "marginBottom": "10px"}),

    # Graph 1
    html.H4(id="title_g1"),
    dcc.Graph(id="g1", config={"displaylogo": False}),

    # Graph 2
    html.H4(id="title_g2"),
    dcc.Graph(id="g2", config={"displaylogo": False}),

    # Graph 3
    html.H4(id="title_g3"),
    dcc.Graph(id="g3", config={"displaylogo": False}),

    html.Hr(),

    # Heatmap
    html.H4("Monthly Î” heatmap (end-of-month âˆ’ start-of-month, bps)"),
    dcc.Graph(id="heatmap", config={"displaylogo": False}),

    html.Hr(),

    # Hedged section (visible ONLY for BOX)
    html.Div(id="hedged-section", children=[
        html.H4("Beta-hedged versions (only when 2 countries & 2 maturities)"),
        html.Div([
            html.Label("Regression window"),
            dcc.RadioItems(
                id="reg_window",
                options=[{"label":"3M","value":"3M"},{"label":"6M","value":"6M"},{"label":"1Y","value":"1Y"}],
                value="6M",
                inline=True
            ),
            html.Span("  |  "),
            html.Label("Beta override"),
            dcc.Input(id="beta_override", type="number", value=None, step=0.01),
            html.Button("Apply", id="beta_apply", n_clicks=0, style={"marginLeft":"8px"}),
            html.Button("Reset", id="beta_reset", n_clicks=0, style={"marginLeft":"8px"}),
        ], style={"marginBottom":"10px"}),

        html.H4(id="title_h1"),
        dcc.Graph(id="h1", config={"displaylogo": False}),
        html.Div(id="beta_table_1", style={"marginBottom":"16px"}),

        html.H4(id="title_h2"),
        dcc.Graph(id="h2", config={"displaylogo": False}),
        html.Div(id="beta_table_2", style={"marginBottom":"16px"}),

        html.H4(id="title_h3"),
        dcc.Graph(id="h3", config={"displaylogo": False}),
        html.Div(id="beta_table_3", style={"marginBottom":"16px"}),
    ]),

    # Store for beta override (effective)
    dcc.Store(id="beta_override_effective", data={"value": None}),
])

# -----------------------------
# Dynamic "hide years" checklist (includes current year)
# -----------------------------
@callback(
    Output("hide-years-container", "children"),
    Input("years-back", "value"),
)
def render_hide_years(N):
    cur = date.today().year
    years = list(range(cur, cur-N-1, -1))  # include current year at start
    return html.Div([
        html.Label("Hide years (exclude from plots & averages)"),
        dcc.Checklist(
            id="hide-years",
            options=[{"label": str(y), "value": y} for y in years],
            value=[],
            inline=True,
            inputStyle={"marginRight":"6px"},
            labelStyle={"marginRight":"12px"}
        )
    ])

# Apply / Reset beta override (global)
@callback(
    Output("beta_override_effective", "data"),
    Input("beta_apply", "n_clicks"),
    Input("beta_reset", "n_clicks"),
    State("beta_override", "value"),
    prevent_initial_call=True
)
def apply_or_reset_beta(n_apply, n_reset, user_beta):
    ctx = dash.callback_context
    if not ctx.triggered:
        raise dash.exceptions.PreventUpdate
    trig = ctx.triggered[0]["prop_id"].split(".")[0]

    if trig == "beta_apply":
        if user_beta is None:
            return {"value": None}
        try:
            return {"value": float(user_beta)}
        except Exception:
            return {"value": None}

    if trig == "beta_reset":
        return {"value": None}

    raise dash.exceptions.PreventUpdate

# -----------------------------
# Main callback
# -----------------------------
@callback(
    Output("data-warning", "children"),
    Output("current-month", "children"),
    Output("series-label", "children"),
    Output("title_g1", "children"), Output("g1", "figure"),
    Output("title_g2", "children"), Output("g2", "figure"),
    Output("title_g3", "children"), Output("g3", "figure"),
    Output("heatmap", "figure"),
    Output("hedged-section", "style"),
    Output("title_h1", "children"), Output("h1", "figure"), Output("beta_table_1", "children"),
    Output("title_h2", "children"), Output("h2", "figure"), Output("beta_table_2", "children"),
    Output("title_h3", "children"), Output("h3", "figure"), Output("beta_table_3", "children"),
    Input("country1", "value"), Input("country2", "value"), Input("country3", "value"),
    Input("maturities", "value"),
    Input("w1", "value"), Input("w2", "value"), Input("w3", "value"),
    Input("years-back", "value"),
    Input("hide-years", "value"),
    Input("reg_window", "value"),
    Input("beta_override_effective", "data"),
)
def update_all(c1, c2, c3, maturities_sel,
               w1, w2, w3,
               years_back, hide_years, reg_window, beta_override_store):

    # Data
    if data is None:
        empty = go.Figure()
        hidden = {"display":"none"}
        return ("No `data` DataFrame found. Provide it via `data_loader.py` or in the global scope.",
                "", "", "", empty, "", empty, "", empty, empty,
                hidden, "", empty, html.Div(), "", empty, html.Div(), "", empty, html.Div())

    # Validate selections
    mats = sorted(list(map(int, (maturities_sel or []))))
    if len([x for x in [c1, c2, c3] if x]) == 0 or len(mats) == 0:
        empty = go.Figure()
        hidden = {"display":"none"}
        return ("", "", "Select at least one country and one maturity.",
                "", empty, "", empty, "", empty, empty,
                hidden, "", empty, html.Div(), "", empty, html.Div(), "", empty, html.Div())

    # Compute weighted series (levels; may be in % or bps depending on data)
    try:
        series, label = compute_weighted_series(
            c1, c2, c3, mats, float(w1 or 1.0), float(w2 or 1.0), float(w3 or 1.0), data
        )
    except Exception as e:
        empty = go.Figure()
        hidden = {"display":"none"}
        return (f"Error computing series: {e}", "", "", "", empty, "", empty, "", empty, empty,
                hidden, "", empty, html.Div(), "", empty, html.Div(), "", empty, html.Div())

    # Convert to bps if values look like % (heuristic)
    series = series.dropna()
    if series.abs().median() < 10:  # <10% median -> likely percent
        series = series * 100.0

    # Years
    curY = date.today().year
    # Build years universe including current year at the top
    years_all = list(range(curY, curY-int(years_back)-1, -1))
    hidden_years = set(hide_years or [])
    years_used = [y for y in years_all if y not in hidden_years]

    # ---------- Graph 1 (01-M -> 01-M+1)
    m_idx = date.today().month
    month_name_short = datetime(curY, m_idx, 1).strftime("%b")
    next_month_short = datetime(2000, m_idx % 12 + 1, 1).strftime("%b")
    profiles_1_all = build_intramonth_profiles(series, m_idx, int(years_back))
    profiles_1 = {y:seg for y,seg in profiles_1_all.items() if y in years_used and y != curY}  # past years only
    title_g1 = f"Seasonality Graph over {len(profiles_1)} past years: 01-{month_name_short} to 01-{next_month_short}"

    fig1 = go.Figure()
    max_x1 = 0
    for y in sorted(profiles_1.keys()):
        seg = profiles_1[y]
        fig1.add_trace(go.Scatter(x=seg.index.values, y=seg.values, mode="lines", name=str(y)))
        if len(seg.index): max_x1 = max(max_x1, int(np.nanmax(seg.index.values)))
    avg1 = build_average_profile(profiles_1)
    if avg1 is not None and len(avg1) > 0:
        fig1.add_trace(go.Scatter(x=avg1.index.values, y=avg1.values, mode="lines", name="Average",
                                  line=dict(width=3, color="black")))
        max_x1 = max(max_x1, int(avg1.index.max()))
    start_calendar_1 = pd.Timestamp(year=curY, month=m_idx, day=1)
    tickvals_1 = list(range(0, max_x1 + 1, 5))
    ticktext_1 = [(start_calendar_1 + pd.Timedelta(days=int(d))).strftime("%d/%m") for d in tickvals_1]
    fig1.update_layout(template="plotly_white", xaxis=dict(tickmode="array", tickvals=tickvals_1, ticktext=ticktext_1, tickangle=0),
                       yaxis_title="bps", legend_title="Year", margin=dict(l=40,r=20,t=40,b=60))

    # ---------- Graph 2 (today d -> d+1M per past year)
    profiles_2_all, stub_2 = build_profiles_anchor_day_next_month(series, int(years_back))
    profiles_2 = {y:seg for y,seg in profiles_2_all.items() if y in years_used and y != curY}
    title_g2 = f"Seasonality Graph over {len(profiles_2)} past years: {stub_2}"
    fig2 = go.Figure()
    max_x2 = 0
    start_calendar_2 = pd.Timestamp(year=curY, month=date.today().month,
                                    day=min(date.today().day, monthrange(curY, date.today().month)[1]))
    for y, seg in sorted(profiles_2.items()):
        fig2.add_trace(go.Scatter(x=seg.index.values, y=seg.values, mode="lines", name=str(y)))
        if len(seg.index): max_x2 = max(max_x2, int(np.nanmax(seg.index.values)))
    avg2 = build_average_profile(profiles_2)
    if avg2 is not None and len(avg2) > 0:
        fig2.add_trace(go.Scatter(x=avg2.index.values, y=avg2.values, mode="lines", name="Average",
                                  line=dict(width=3, color="black")))
        max_x2 = max(max_x2, int(avg2.index.max()))
    tickvals_2 = list(range(0, max_x2 + 1, 5))
    ticktext_2 = [(start_calendar_2 + pd.Timedelta(days=int(d))).strftime("%d/%m") for d in tickvals_2]
    fig2.update_layout(template="plotly_white", xaxis=dict(tickmode="array", tickvals=tickvals_2, ticktext=ticktext_2, tickangle=0),
                       yaxis_title="bps", legend_title="Year", margin=dict(l=40,r=20,t=40,b=60))

    # ---------- Graph 3 (next month 01 -> 01)
    profiles_3_all, stub_3 = build_profiles_next_month(series, int(years_back))
    profiles_3 = {y:seg for y,seg in profiles_3_all.items() if y in years_used and y != curY}
    title_g3 = f"Seasonality Graph over {len(profiles_3)} past years: {stub_3}"
    fig3 = go.Figure()
    tm = date.today().month
    ty = curY
    start_calendar_3 = pd.Timestamp(year=ty+1, month=1, day=1) if tm==12 else pd.Timestamp(year=ty, month=tm+1, day=1)
    max_x3 = 0
    for y, seg in sorted(profiles_3.items()):
        fig3.add_trace(go.Scatter(x=seg.index.values, y=seg.values, mode="lines", name=str(y)))
        if len(seg.index): max_x3 = max(max_x3, int(np.nanmax(seg.index.values)))
    avg3 = build_average_profile(profiles_3)
    if avg3 is not None and len(avg3) > 0:
        fig3.add_trace(go.Scatter(x=avg3.index.values, y=avg3.values, mode="lines", name="Average",
                                  line=dict(width=3, color="black")))
        max_x3 = max(max_x3, int(avg3.index.max()))
    tickvals_3 = list(range(0, max_x3 + 1, 5))
    ticktext_3 = [(start_calendar_3 + pd.Timedelta(days=int(d))).strftime("%d/%m") for d in tickvals_3]
    fig3.update_layout(template="plotly_white", xaxis=dict(tickmode="array", tickvals=tickvals_3, ticktext=ticktext_3, tickangle=0),
                       yaxis_title="bps", legend_title="Year", margin=dict(l=40,r=20,t=40,b=60))

    # ---------- Heatmap ----------
    include_current = (curY in years_used)
    past_years = [y for y in years_used if y != curY]
    heat_years = past_years
    df_heat = build_heatmap_df(series, heat_years, include_current_year=include_current)
    fig_heat = heatmap_figure(df_heat)

    # ---------- Beta-hedged graphs (only if BOX: exactly 2 countries & 2 maturities)
    hedged_style = {"display":"none"}
    title_h1 = title_h2 = title_h3 = ""
    fig_h1 = fig_h2 = fig_h3 = go.Figure()
    tbl1 = tbl2 = tbl3 = html.Div()

    c_sel = [c for c in [c1, c2, c3] if c]
    is_box = (len(c_sel) == 2 and len(mats) == 2 and c1 is not None)
    Cx = None
    if is_box:
        Cx = c2 if (c2 and c1 != c2) else c3
        is_box = (Cx is not None)

    if is_box and Cx is not None:
        hedged_style = {"display":"block"}
        mS, mL = mats[0], mats[1]
        # Canonical definitions for regression
        box_bps, long_bps = build_canonical_box_and_long(c1, Cx, mS, mL, data)

        def compute_hedged(get_start_fn, title_stub: str):
            ylist = [y for y in years_used if y != curY]  # past years only
            lookback = lookback_delta(reg_window)
            profiles = {}
            betas = {}
            max_x = 0

            fig = go.Figure()

            for y in ylist:
                start_dt = get_start_fn(y)
                end_dt = window_end_one_month_after(start_dt)

                # Regression window: [start_dt - lookback, start_dt)
                reg_start = start_dt - lookback
                y_box_lvl  = slice_window_segment_levels(box_bps,  reg_start, start_dt)
                x_long_lvl = slice_window_segment_levels(long_bps, reg_start, start_dt)

                # Determine beta to use (override if applied)
                beta_override = beta_override_store.get("value") if isinstance(beta_override_store, dict) else None
                beta = float(beta_override) if beta_override is not None else regression_beta(y_box_lvl, x_long_lvl)
                if beta is None:
                    continue
                betas[y] = beta

                # Plot window: [start_dt, end_dt]
                seg_box_lvl  = slice_window_segment_levels(box_bps,  start_dt, end_dt)
                seg_long_lvl = slice_window_segment_levels(long_bps, start_dt, end_dt)
                df_al = align_on_index([seg_box_lvl, seg_long_lvl])
                if df_al.empty:
                    continue
                hedged_lvl = df_al.iloc[:,0] - beta * df_al.iloc[:,1]
                hedged_centered = hedged_lvl - hedged_lvl.iloc[0]
                seg = pd.Series(hedged_centered.values, index=(df_al.index - pd.Timestamp(start_dt)).days)
                profiles[y] = seg
                fig.add_trace(go.Scatter(x=seg.index.values, y=seg.values, mode="lines", name=str(y)))
                if len(seg.index): max_x = max(max_x, int(np.nanmax(seg.index.values)))

            # Average
            avg = build_average_profile(profiles)
            if avg is not None and len(avg) > 0:
                fig.add_trace(go.Scatter(x=avg.index.values, y=avg.values, mode="lines", name="Average",
                                         line=dict(width=3, color="black")))
                if len(avg.index): max_x = max(max_x, int(avg.index.max()))

            # x ticks
            start_calendar = pd.Timestamp(get_start_fn(curY))
            tickvals = list(range(0, max_x + 1, 5))
            ticktext = [(start_calendar + pd.Timedelta(days=int(d))).strftime("%d/%m") for d in tickvals]
            fig.update_layout(template="plotly_white",
                              xaxis=dict(tickmode="array", tickvals=tickvals, ticktext=ticktext, tickangle=0),
                              yaxis_title="bps (hedged)", legend_title="Year", margin=dict(l=40,r=20,t=40,b=60))

            # Beta table
            cols = [{"name": str(y), "id": str(y)} for y in ylist]
            values = [{str(y): (f"{betas[y]:.3f}" if y in betas else "") for y in ylist}]
            table = dash_table.DataTable(
                columns=cols,
                data=values,
                style_table={"overflowX":"auto"},
                style_cell={"textAlign":"center", "minWidth":"70px"},
                style_header={"fontWeight":"bold"},
            )
            return fig, table

        month_short = datetime(curY, m_idx, 1).strftime("%b")
        next_short = datetime(2000, m_idx % 12 + 1, 1).strftime("%b")
        title_h1 = f"Hedged â€” 01-{month_short} to 01-{next_short}"
        _, stub_2_h = build_profiles_anchor_day_next_month(series, int(years_back))
        _, stub_3_h = build_profiles_next_month(series, int(years_back))
        title_h2 = f"Hedged â€” {stub_2_h}"
        title_h3 = f"Hedged â€” {stub_3_h}"

        fig_h1, tbl1 = compute_hedged(window_start_graph1, title_h1)
        fig_h2, tbl2 = compute_hedged(window_start_graph2, title_h2)
        fig_h3, tbl3 = compute_hedged(window_start_graph3, title_h3)

    month_name_long = datetime(curY, m_idx, 1).strftime("%B")
    return (
        "", f"Current month: {month_name_long}", label,
        title_g1, fig1,
        title_g2, fig2,
        title_g3, fig3,
        fig_heat,
        hedged_style,
        title_h1, fig_h1, tbl1,
        title_h2, fig_h2, tbl2,
        title_h3, fig_h3, tbl3,
    )

# -----------------------------
# Run
# -----------------------------
if __name__ == "__main__":
    # Run and share on LAN; open local browser automatically (ASCII-only prints)
    import webbrowser
    import socket

    def get_local_ip():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    host = "0.0.0.0"
    port = 8050
    local_ip = get_local_ip()

    print("\n================= SHARE THIS =================")
    print("Local (you) : http://localhost:{port}".format(port=port))
    print("LAN (team)  : http://{ip}:{port}".format(ip=local_ip, port=port))
    print("==============================================\n")

    try:
        webbrowser.open("http://localhost:{port}".format(port=port))
    except Exception:
        pass

    app.run_server(host=host, port=port, debug=False)
